/*++

Copyright (c) 
 
Module Name:
 
    SafeModel.c

Abstract:

    This framework is generated by QuickSYS 0.4

Author:

    <your name>

Environment:

    Kernel mode only.

Revision History:

    N.B.
    __except_handler4 is used by VC8 if BufferSecurityCheck(/GS) is on, supported by WDK.
    Turn it off when using old DDK and VC8 will use __except_handler3.

    If BufferSecurityCheck(/GS) is on, change entry point to GsDriverEntry@8 and add BufferOverflowK.lib.

    For x64, change _X86_=1 to _AMD64=1, include directory to ddk\wnet, lib path to lib\wnet\amd64.

--*/

#include "precomp.h"
#include "safe.h"
//#include <ntstrsafe.h>

WIN_VER_DETAIL g_WinVer;

KEVENT g_RunEvent;

struct MESSAGE *g_pMessage=0;
struct REGDATA *g_pRegData=0;
struct ADDRDATA *g_pAddrData=0;
struct HOOKDATA *g_pHookData=0;
struct SECTIONDATA *g_pSectionData=0;
PTIME_FIELDS g_pTime=0;

PEPROCESS g_CsrssProcess,g_MyProcess=0,g_SystemProcess,g_SmssProcess,g_WinlogonProcess,g_ServicesProcess,g_LsassProcess;
HANDLE g_MyProcessId=0;
PKAPC_STATE ApcState;
PServiceDescriptorTableEntry KeServiceDescriptorTableShadow=0;
extern PServiceDescriptorTableEntry KeServiceDescriptorTable;

//extern BOOLEAN PsIsThreadTerminating(IN PETHREAD  Thread);

BOOL bIsUnload=FALSE;

PVOID  AppeventObject = NULL;
PVOID  SyseventObject = NULL;

ULONG SSDTTableBase=0;

ULONG  Index_NtUserFindWindowEx        = 0; //NtUserFindWindowEx的索引号
ULONG  Index_NtUserGetForegroundWindow = 0; //NtUserGetForegroundWindow的索引号
ULONG  Index_NtUserQueryWindow         = 0; //NtUserQueryWindow的索引号
ULONG  Index_NtUserBuildHwndList       = 0; //NtUserBuildHwndList的索引号
ULONG  Index_NtUserWindowFromPoint     = 0; //NtUserWindowFromPoint的索引号
ULONG  Index_NtUserSetWindowsHookEx    = 0; //NtUserSetWindowsHookEx的索引号
ULONG  Index_NtUserGetDC               = 0;
ULONG  Index_NtUserGetDCEx             = 0;
ULONG  Index_NtUserSendInput           = 0;
ULONG  Index_NtUserSetInformationThread= 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG Real_ZwCreateProcess                    =0;
ULONG Real_ZwCreateProcessEx                    =0;
ULONG Real_NtCreateUserProcess                =0;
ULONG Real_ZwSetValueKey                        =0;
ULONG Real_ZwLoadDriver                            =0;
ULONG Real_ZwSetSystemTime                    =0;
ULONG Real_ZwWriteVirtualMemory            =0;
ULONG Real_NtSetSystemInformation            =0;
ULONG Real_NtWriteFile                                =0;
ULONG Real_NtSystemDebugControl            =0;
ULONG Real_ZwOpenSection                        =0;
ULONG Real_NtReadFile                                =0;

ULONG Real_NtUserSetWindowsHookEx        =0;

int Index_ZwCreateProcess                    =0;
int Index_ZwCreateProcessEx                =0;
int Index_NtCreateUserProcess            =0;
int Index_ZwSetValueKey                        =0;
int Index_ZwLoadDriver                        =0;
int Index_ZwSetSystemTime                    =0;
int Index_ZwWriteVirtualMemory            =0;
int Index_NtSetSystemInformation        =0;
int Index_NtSystemDebugControl        =0;
int Index_NtWriteFile                            =0;
int Index_NtOpenProcess                    =0;
int Index_ZwOpenSection                    =0;
int Index_NtReadFile                            =0;

BOOL State_ZwCreateProcess                =FALSE;
BOOL State_ZwCreateProcessEx            =FALSE;
BOOL State_NtCreateUserProcess            =FALSE;
BOOL State_ZwSetValueKey                =FALSE;
BOOL State_ZwLoadDriver                    =FALSE;
BOOL State_ZwSetSystemTime                =FALSE;
BOOL State_ZwWriteVirtualMemory            =FALSE;
BOOL State_NtSetSystemInformation        =FALSE;
BOOL State_NtSystemDebugControl            =FALSE;
BOOL State_NtWriteFile                    =FALSE;
BOOL State_NtOpenProcess                =FALSE;
BOOL State_ZwOpenSection                =FALSE;
BOOL State_NtReadFile                        =FALSE;

BOOL State_NtUserSetWindowsHookEx        =FALSE;

ULONG Quote_HookDrive                    =0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, GetWindowsVersion)
#pragma alloc_text(INIT, InitShadowCallIndex)
#pragma alloc_text(INIT, InitSysCallIndex)
#pragma alloc_text(INIT, GetInfoTable)
#pragma alloc_text(INIT, GetProcPidByObjName)

#pragma alloc_text(PAGE, SafemodelDispatchCreate)
#pragma alloc_text(PAGE, SafemodelDispatchClose)
#pragma alloc_text(PAGE, SafemodelDispatchDeviceControl)
#pragma alloc_text(PAGE, SafemodelUnload)
#endif // ALLOC_PRAGMA

NTSTATUS
DDKAPI DriverEntry(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS            status;    
    UNICODE_STRING        ntDeviceName;
    UNICODE_STRING        dosDeviceName;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_OBJECT        deviceObject = NULL;
    BOOLEAN                symbolicLink = FALSE;
/*
    UNICODE_STRING        uNetDeviceName;
    PDEVICE_OBJECT        pDevice_Object;
    PFILE_OBJECT        pFile_Object;
    KEVENT                event;
    PIRP                pIrp;
    IO_STATUS_BLOCK        ioStatus;
    PF_SET_EXTENSION_HOOK_INFO pFilterData;
*/
    dprintf("[SafeModel] DriverEntry: %wZ\n", RegistryPath);

    //
    // TODO:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports
    //

    RtlInitUnicodeString(&ntDeviceName, SAFEMODEL_DEVICE_NAME_W);

    status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_EXTENSION),        // DeviceExtensionSize
        &ntDeviceName,                    // DeviceName
        FILE_DEVICE_SAFEMODEL,    // DeviceType
        0,                                // DeviceCharacteristics
        TRUE,                            // Exclusive
        &deviceObject                    // [OUT]
        );

    if (!NT_SUCCESS(status))
    {
        dprintf("[SafeModel] IoCreateDevice failed(0x%x).\n", status);
        goto failed;
    }
/*
    RtlInitUnicodeString(&uNetDeviceName, "\\Device\\IPFILTERDRIVER");
    status=IoGetDeviceObjectPointer(&uNetDeviceName,FILE_ALL_ACCESS,&pFile_Object,&pDevice_Object);
    if (!NT_SUCCESS(status))
    {
        dprintf("[SafeModel] IoGetDeviceObjectPointer failed(0x%x).\n", status);
        goto failed;
    }
    KeInitializeEvent(&event,NotificationEvent,FALSE);
    pIrp=IoBuildDeviceIoControlRequest(IOCTL_PF_SET_EXTENSION_POINTER,
        pDevice_Object,
        pFilterData,
        sizeof(PF_SET_EXTENSION_HOOK_INFO),
        NULL,NULL,FALSE,&event,&ioStatus
        );
*/
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // TODO: set up synchronization objects, state info,, etc.
    //

    RtlInitUnicodeString(&dosDeviceName, SAFEMODEL_DOS_DEVICE_NAME_W);

    status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);

    if (!NT_SUCCESS(status))
    {
        dprintf("[SafeModel] IoCreateSymbolicLink failed(0x%x).\n", status);
        goto failed;
    }

    symbolicLink = TRUE;

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SafemodelDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SafemodelDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SafemodelDispatchDeviceControl;
    DriverObject->DriverUnload                         = SafemodelUnload;

    if (NT_SUCCESS(status))
    {
        KeInitializeEvent(&g_RunEvent,SynchronizationEvent,TRUE);
        g_WinVer=GetWindowsVersion();
        InitShadowCallIndex();
        InitSysCallIndex();
        GetShadowTable();
        SSDTTableBase=(ULONG)KeServiceDescriptorTable->ServiceTableBase;
        dprintf("SSDTTableBase(0x%x).\n", SSDTTableBase);
        bIsUnload=FALSE;
        g_SystemProcess=PsGetCurrentProcess();
        PsLookupProcessByProcessId(GetProcPidByObjName(L"\\SmApiPort",10), &g_SmssProcess);
        if (!NT_SUCCESS(status))
        {
            dprintf("PsLookupProcessByProcessId(g_SmssProcess) error\n");
        }
        PsLookupProcessByProcessId(GetProcPidByObjName(L"\\RPC Control\\sclogonrpc",23), &g_WinlogonProcess);
        if (!NT_SUCCESS(status))
        {
            dprintf("PsLookupProcessByProcessId(g_WinlogonProcess) error\n");
        }
        PsLookupProcessByProcessId(GetProcPidByObjName(L"\\RPC Control\\ntsvcs",18), &g_ServicesProcess);
        if (!NT_SUCCESS(status))
        {
            dprintf("PsLookupProcessByProcessId(g_ServicesProcess) error\n");
        }
        PsLookupProcessByProcessId(GetProcPidByObjName(L"\\SeLsaCommandPort",17), &g_LsassProcess);
        if (!NT_SUCCESS(status))
        {
            dprintf("PsLookupProcessByProcessId(g_LsassProcess) error\n");
        }
        status=PsLookupProcessByProcessId(GetProcPidByObjName(L"\\Windows\\ApiPort",16), &g_CsrssProcess);
        if (!NT_SUCCESS(status))
        {
            dprintf("PsLookupProcessByProcessId(g_CsrssProcess) error\n");
        }
        return status;
    }

failed:
    dprintf("[SafeModel] DriverEntry:Failed\n");
    if (symbolicLink)
        IoDeleteSymbolicLink(&dosDeviceName);

    if (deviceObject)
        IoDeleteDevice(deviceObject);

    return status;
}

NTSTATUS
DDKAPI SafemodelDispatchCreate(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PIRP                    Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

    dprintf("[SafeModel] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);


    return status;
}

NTSTATUS
DDKAPI SafemodelDispatchClose(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PIRP                    Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

    dprintf("[SafeModel] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
DDKAPI SafemodelDispatchDeviceControl(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PIRP                    Irp
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION    irpSp;
    PDEVICE_EXTENSION    deviceExtension;
    PVOID                ioBuffer;
    ULONG                inputBufferLength, outputBufferLength;
    ULONG                ioControlCode;
    PVOID                pUserBuffer;
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer            = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength    = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength    = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode        = irpSp->Parameters.DeviceIoControl.IoControlCode;
    pUserBuffer            = Irp->UserBuffer;
    
    switch (ioControlCode)
    {
    case DRIVE_INITIALIZE:
        g_MyProcess=PsGetCurrentProcess();
        g_MyProcessId=PsGetCurrentProcessId();
        if (ioBuffer)
        {
            g_pMessage=(struct MESSAGE*)MmMapIoSpace(MmGetPhysicalAddress(*(void**)ioBuffer),sizeof(struct MESSAGE),MmNonCached );
            if (g_pMessage)
            {
                status=ObReferenceObjectByHandle(g_pMessage->Appevent,GENERIC_ALL,NULL,KernelMode,&AppeventObject,NULL);
                status=ObReferenceObjectByHandle(g_pMessage->Sysevent,GENERIC_ALL,NULL,KernelMode,&SyseventObject,NULL);
                if (NT_SUCCESS(status))
                {
                    dprintf("DRIVE_INITIALIZE_SUCCESS\n");
                }
                else
                {
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case SET_VALUEKEY_MONITOR_ON:
        if (ioBuffer)
        {
            g_pRegData=(struct REGDATA*)MmMapIoSpace(MmGetPhysicalAddress(*(void**)ioBuffer),sizeof(struct REGDATA),MmNonCached );
            if (g_pRegData)
            {
                RegMoniterOn();
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case SET_VALUEKEY_MONITOR_OFF:
        if (g_pRegData)
        {
            RegMoniterOff();
            MmUnmapIoSpace(g_pRegData,sizeof(struct REGDATA));
            g_pRegData=0;
        }
        break;
    case SET_SYSTEMTIME_MONITOR_ON:
        if (ioBuffer)
        {
            g_pTime=(PTIME_FIELDS)MmMapIoSpace(MmGetPhysicalAddress(*(void**)ioBuffer),sizeof(struct _TIME_FIELDS),MmNonCached );
            if (g_pTime)
            {
                TimeSafeOn();
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case SET_SYSTEMTIME_MONITOR_OFF:
        if (g_pTime)
        {
            TimeSafeOff();
            MmUnmapIoSpace(g_pTime,sizeof(struct _TIME_FIELDS));
            g_pTime=0;
        }
        break;
    case SET_HOOK_MONITOR_ON:
        if (ioBuffer)
        {
            g_pHookData=(struct HOOKDATA*)MmMapIoSpace(MmGetPhysicalAddress(*(void**)ioBuffer),sizeof(struct HOOKDATA),MmNonCached );
            if (g_pHookData)
            {
                HookMoniterOn();
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case SET_HOOK_MONITOR_OFF:
        if (g_pHookData)
        {
            HookMoniterOff();
            MmUnmapIoSpace(g_pHookData,sizeof(struct HOOKDATA));
            g_pHookData=0;
        }
        break;
    case WRITE_VIRTUAL_MEMORY_ON:
        if (ioBuffer)
        {
            g_pAddrData=(struct ADDRDATA*)MmMapIoSpace(MmGetPhysicalAddress(*(void**)ioBuffer),sizeof(struct ADDRDATA),MmNonCached );
            if (g_pAddrData)
            {
                WriteVirtualMemoryOn();
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case WRITE_VIRTUAL_MEMORY_OFF:
        if (g_pAddrData)
        {
            WriteVirtualMemoryOff();
            MmUnmapIoSpace(g_pAddrData,sizeof(struct ADDRDATA));
            g_pAddrData=0;
        }
        break;
    case OPEN_SECTION_MONITOR_ON:
        if (ioBuffer)
        {
            g_pSectionData=(struct SECTIONDATA*)MmMapIoSpace(MmGetPhysicalAddress(*(void**)ioBuffer),sizeof(struct SECTIONDATA),MmNonCached );
            if (g_pSectionData)
            {
                OpenSectionOn();
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case OPEN_SECTION_MONITOR_OFF:
        if (g_pSectionData)
        {
            OpenSectionOff();
            MmUnmapIoSpace(g_pSectionData,sizeof(struct SECTIONDATA));
            g_pSectionData=0;
        }
        break;
    case SYSTEM_DEBUG_MONITER_ON:
        SystemDebugMoniterOn();
        break;
    case SYSTEM_DEBUG_MONITER_OFF:
        SystemDebugMoniterOff();
        break;
    case WRITE_FILE_MONITOR_ON:
        WriteFileMoniterOn();
        break;
    case WRITE_FILE_MONITOR_OFF:
        WriteFileMoniterOff();
        break;
    case CRATE_PROCESS_MONITOR_ON:
        ProcMoniterOn();
        break;
    case CRATE_PROCESS_MONITOR_OFF:
        ProcMoniterOff();
        break;
    case LOAD_DRIVE_MONITOR_ON:
        ModMonitorOn();
        break;
    case LOAD_DRIVE_MONITOR_OFF:
        ModMonitorOff();
        break;
    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    //
    // TODO: if not pending, call IoCompleteRequest and Irp is freed.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID DDKAPI SafemodelUnload(IN PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING dosDeviceName;
    NTSTATUS status;

    
    //
    // Free any resources
    //
    bIsUnload=TRUE;
    ProcMoniterOff();
    RegMoniterOff();
    ModMonitorOff();
    TimeSafeOff();
    HookMoniterOff();
    WriteFileMoniterOff();
    SystemDebugMoniterOff();
    WriteVirtualMemoryOff();
    OpenSectionOff();

    while (Quote_HookDrive)
    {
        g_pMessage->state=TRUE;
        KeSetEvent((PRKEVENT)SyseventObject,0,0);
    }
/*
    g_Message->state=TRUE;
    KeSetEvent((PRKEVENT)SyseventObject,0,0);*/
    Sleep(10);
//    KeWaitForSingleObject(&g_RunEvent,Executive,KernelMode,0,0);
    if (g_pMessage)
    {
        MmUnmapIoSpace(g_pMessage,sizeof(struct MESSAGE));
    }
    if (g_pRegData)
    {
        MmUnmapIoSpace(g_pRegData,sizeof(struct REGDATA));
    }
    if (g_pAddrData)
    {
        MmUnmapIoSpace(g_pAddrData,sizeof(struct ADDRDATA));
    }
    if (g_pHookData)
    {
        MmUnmapIoSpace(g_pHookData,sizeof(struct HOOKDATA));
    }
    if (g_pTime)
    {
        MmUnmapIoSpace(g_pTime,sizeof(struct _TIME_FIELDS));
    }
    if (g_pSectionData)
    {
        MmUnmapIoSpace(g_pSectionData,sizeof(struct SECTIONDATA));
    }
    ObDereferenceObject(AppeventObject);
    ObDereferenceObject(SyseventObject);

    //
    // Delete the symbolic link
    //

    RtlInitUnicodeString(&dosDeviceName, SAFEMODEL_DOS_DEVICE_NAME_W);

    IoDeleteSymbolicLink(&dosDeviceName);

    //
    // Delete the device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    dprintf("[SafeModel] unloaded\n");
}
PVOID GetInfoTable(ULONG ATableType)
{
    ULONG mSize = 0x4000;
    PVOID mPtr = NULL;
    NTSTATUS St;
    do
    {
        mPtr = ExAllocatePool(PagedPool, mSize);
        memset(mPtr, 0, mSize);
        if (mPtr)
        {
            St = ZwQuerySystemInformation(ATableType, mPtr, mSize, NULL);
        } else return NULL;
        if (St == STATUS_INFO_LENGTH_MISMATCH)
        {
            ExFreePool(mPtr);
            mSize = mSize * 2;
        }
    } while (St == STATUS_INFO_LENGTH_MISMATCH);
    if (St == STATUS_SUCCESS) return mPtr;
    ExFreePool(mPtr);
    return NULL;
}

HANDLE GetProcPidByObjName(PWCHAR pwObjName,int iSize)
{
    HANDLE Process, hObject;
    HANDLE CsrId = (HANDLE)0;
    OBJECT_ATTRIBUTES obj;
    CLIENT_ID cid;
    UCHAR Buff[0x100];
    POBJECT_NAME_INFORMATION ObjName = (PVOID)&Buff;
    PSYSTEM_HANDLE_INFORMATION_EX Handles;
    ULONG r;

    Handles = GetInfoTable(SystemHandleInformation);

    if (!Handles) return CsrId;

    for (r = 0; r < Handles->NumberOfHandles; r++)
    {
        if (Handles->Information[r].ObjectTypeNumber == 21) //Port object
        {
            InitializeObjectAttributes(&obj, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

            cid.UniqueProcess = (HANDLE)Handles->Information[r].ProcessId;
            cid.UniqueThread = 0;

            if (NT_SUCCESS(NtOpenProcess(&Process, PROCESS_DUP_HANDLE, &obj, &cid)))
            {
                if (NT_SUCCESS(ZwDuplicateObject(Process, (HANDLE)Handles->Information[r].Handle,NtCurrentProcess(), &hObject, 0, 0, DUPLICATE_SAME_ACCESS)))
                {
                    if (NT_SUCCESS(ZwQueryObject(hObject, ObjectNameInformation, ObjName, 0x100, NULL)))
                    {
//                        dprintf("ID:%d    ObjName:%ws\n",Handles->Information[r].ProcessId,ObjName->Name.Buffer);
//                        if (ObjName->Name.Buffer && !wcsncmp(L"\\Windows\\ApiPort", ObjName->Name.Buffer, 20))
                        if(ObjName->Name.Buffer && !wcsncmp(pwObjName, ObjName->Name.Buffer, iSize))
                        {
                            CsrId = (HANDLE)Handles->Information[r].ProcessId;
                        } 
                    }

                    ZwClose(hObject);
                }

                ZwClose(Process);
            }
        }
    }

    ExFreePool(Handles);
    return CsrId;
}
/*
VOID ZeroMemory(VOID* pobj,int len)
{
    _asm
    {
        xor eax,eax
        mov edi,pobj
        mov ecx,len
        cld
        rep stosb
    }
}


BOOLEAN Sleep(ULONG MillionSecond)
{
    NTSTATUS ntStatus;
    LARGE_INTEGER DelayTime;
    DelayTime = RtlConvertLongToLargeInteger(-10000*MillionSecond);
    ntStatus = KeDelayExecutionThread( KernelMode, FALSE, &DelayTime );
    if( NT_SUCCESS(ntStatus) )
        return TRUE;
    else
        return FALSE;
}
*/

WIN_VER_DETAIL GetWindowsVersion()
{
    RTL_OSVERSIONINFOEXW osverinfo = { sizeof(osverinfo) }; 
    
    PsGetVersion(&osverinfo.dwMajorVersion, &osverinfo.dwMinorVersion, &osverinfo.dwBuildNumber, NULL);

    if (osverinfo.dwMajorVersion == 5 && osverinfo.dwMinorVersion == 0) 
    {
        dprintf("WINDOWS_VERSION_2K\n");
        return WINDOWS_VERSION_2K;
    } else if (osverinfo.dwMajorVersion == 5 && osverinfo.dwMinorVersion == 1) 
    {
        dprintf("WINDOWS_VERSION_XP\n");
        return WINDOWS_VERSION_XP;
    } else if (osverinfo.dwMajorVersion == 5 && osverinfo.dwMinorVersion == 2) 
    {
        if (osverinfo.wServicePackMajor==0) 
        { 
            dprintf("WINDOWS_VERSION_2K3\n");
            return WINDOWS_VERSION_2K3;
        } else 
        {
            dprintf("WINDOWS_VERSION_2K3_SP1_SP2\n");
            return WINDOWS_VERSION_2K3_SP1_SP2;
        }
    } else if (osverinfo.dwMajorVersion == 6 && osverinfo.dwMinorVersion == 0) 
    {
        dprintf("WINDOWS_VERSION_VISTA\n");
        return WINDOWS_VERSION_VISTA;
    }
    dprintf("WINDOWS_VERSION_NONE\n");
    return WINDOWS_VERSION_NONE;
}
int ConvertFileNameWCHARToCHAR(PWCHAR pWChar, PCHAR pChar)
{
    UNICODE_STRING usFileName;
    ANSI_STRING asFileName;

    RtlInitUnicodeString(&usFileName, pWChar);

    asFileName.Length = 0;
    asFileName.MaximumLength = 256;
    asFileName.Buffer = pChar;

    RtlUnicodeStringToAnsiString(&asFileName, &usFileName, FALSE);
    pChar[asFileName.Length] = 0;
    return asFileName.Length;
}

int ConvertFileNameUNISTRToCHAR(PUNICODE_STRING usFileName, PCHAR pChar)
{
    ANSI_STRING asFileName;

    asFileName.Length = 0;
    asFileName.MaximumLength = 256;
    asFileName.Buffer = pChar;

    RtlUnicodeStringToAnsiString(&asFileName, usFileName, FALSE);
    pChar[asFileName.Length] = 0;
    return asFileName.Length;
}
NTSTATUS   GetFilePathVista(HANDLE  KeyHandle,char   *fullname)  //取子进程文件名
{
    PFILE_OBJECT   pKey=NULL;
    ULONG              retSize;
    NTSTATUS   ns;
    UNICODE_STRING   dosName;
    char aPathName[MAX_PATH];
    __try
    {
        if (KeyHandle==0) return STATUS_ACCESS_DENIED;
        if (NT_SUCCESS(ObReferenceObjectByHandle(KeyHandle,0,IoFileObjectType,KernelMode,&pKey,NULL)))
        {
            if (NT_SUCCESS(RtlVolumeDeviceToDosName(pKey->DeviceObject,&dosName)))
            {
                ConvertFileNameUNISTRToCHAR(&dosName,fullname);
            }
            ConvertFileNameUNISTRToCHAR(&pKey->FileName,aPathName);
            ObDereferenceObject(pKey);
            RtlStringCchCatA(fullname,MAX_PATH,aPathName);
            return STATUS_SUCCESS;
        }
        return STATUS_ACCESS_DENIED;
    }
    //__except(EXCEPTION_EXECUTE_HANDLER)
    //{
    //    ZeroMemory(fullname,MAX_PATH);
    //    return STATUS_SEVERITY_WARNING;
    //}
    
}

NTSTATUS   GetFilePath2000_2003(HANDLE     KeyHandle,char   *fullname)  //取文件路径名
{
    NTSTATUS   ns;
    PVOID   pKey=NULL,pFile=NULL;
    UNICODE_STRING                   fullUniName;
    ANSI_STRING                           akeyname;
    ULONG   actualLen;   
    UNICODE_STRING   dosName;

    if (KeyHandle==0) return   STATUS_ACCESS_DENIED;

    fullUniName.Buffer=NULL;
    fullUniName.Length=0;   
    fullname[0]=0x00;
    ns=ObReferenceObjectByHandle(KeyHandle,0,NULL,KernelMode,&pKey,NULL);
    if(!NT_SUCCESS(ns))   return ns;
    fullUniName.Buffer = ExAllocatePool(   PagedPool,   MAX_PATH*2);//1024*2
    fullUniName.MaximumLength =MAX_PATH*2;
    __try
    {
        pFile=(PVOID)*(ULONG   *)((char   *)pKey+20);
        pFile=(PVOID)*(ULONG   *)((char   *)pFile);
        pFile=(PVOID)*(ULONG   *)((char   *)pFile+36);

        ObReferenceObjectByPointer(pFile,   0,   NULL,   KernelMode);
        //DbgPrintEx(DPFLTR_IHVBUS_ID ,DPFLTR_ERROR_LEVEL,"%08x",RealIoVolumeDeviceToDosName);

        RtlVolumeDeviceToDosName(((PFILE_OBJECT)pFile)->DeviceObject,&dosName);

        RtlCopyUnicodeString(&fullUniName,   &dosName);
        RtlAppendUnicodeStringToString(&fullUniName,&((PFILE_OBJECT)pFile)->FileName);
        ObDereferenceObject(pFile);
        ObDereferenceObject(pKey);
        RtlUnicodeStringToAnsiString(&akeyname,&fullUniName,TRUE);
        if(akeyname.Length<MAX_PATH)     
        {   
            memcpy(fullname,akeyname.Buffer,akeyname.Length);   
            fullname[akeyname.Length]=0x00;   
        }   
        else   
        {   
            memcpy(fullname,akeyname.Buffer,MAX_PATH);   
            fullname[MAX_PATH-1]=0x00;   
        }

        RtlFreeAnsiString(&akeyname);   
        ExFreePool(dosName.Buffer);   
        ExFreePool(fullUniName.Buffer);  
        return   STATUS_SUCCESS;
    }
    //__except(1)   
    //{   
    //    if(fullUniName.Buffer) ExFreePool(fullUniName.Buffer);   
    //    if(pKey)   ObDereferenceObject(pKey   );   
    //    return   STATUS_SUCCESS;
    //}
}

NTSTATUS   GetFilePath(HANDLE     KeyHandle,char   *fullname)
{
    NTSTATUS   ns;
    if (WINDOWS_VERSION_VISTA==g_WinVer)
    {
        ns=GetFilePathVista(KeyHandle,fullname);
        if (!NT_SUCCESS(ns))
        {
            goto ERROR;
        }
    }
    else
    {
        ns=GetFilePath2000_2003(KeyHandle,fullname);
        if (!NT_SUCCESS(ns))
        {
            goto ERROR;
        }
        
    }
    return ns;
ERROR:
    memcpy(fullname,"Get File Path Fall",sizeof("Get File Path Fall"));
    return ns;
}
BOOLEAN GetRegPath(HANDLE handle,PCHAR pKeyPath)   //取注册表路径
{

    ULONG uactLength;
    POBJECT_NAME_INFORMATION  pustr;
    PVOID pObj;
    NTSTATUS ns;
    if (handle==0) goto ERROR;
    ns = ObReferenceObjectByHandle( handle, 0, NULL, KernelMode, &pObj, NULL );
    if (!NT_SUCCESS(ns))
    {
        goto ERROR;
    }
    pustr = ExAllocatePool(NonPagedPool,1024+4);

    if (pObj==NULL||pKeyPath==NULL)
        goto ERROR;

    ns = ObQueryNameString(pObj,pustr,512,&uactLength);

    if (NT_SUCCESS(ns))
    {
        ConvertFileNameUNISTRToCHAR(&pustr->Name,pKeyPath);
    }
    ExFreePool(pustr);
    if (pObj)
    {
        ObDereferenceObject(pObj);
    }
    return TRUE;
ERROR:
    RtlStringCchCopyA(pKeyPath,MAX_PATH,"Get REG Path Fall");
    return FALSE;
}
BOOL GetProcessName(PEPROCESS pProcess,PCHAR pProcessName)     //取进程名
{
    ZeroMemory(pProcessName,MAX_PATH);
    __try
    {
        switch(g_WinVer)
        {
        case WINDOWS_VERSION_2K:
            pProcess=((ULONG)pProcess)+0x1fc;
            break;
        case WINDOWS_VERSION_XP:
            pProcess=((ULONG)pProcess)+0x174;
            break;
        case WINDOWS_VERSION_2K3:
            pProcess=((ULONG)pProcess)+0x154;
            break;
        case WINDOWS_VERSION_2K3_SP1_SP2:
           pProcess=((ULONG)pProcess)+0x164;
            break;
        case WINDOWS_VERSION_VISTA:
            pProcess=((ULONG)pProcess)+0x14c;
            break;
        }
        memcpy((PVOID)pProcessName,(char*)pProcess,16);
        return TRUE;
    }
    //__except(EXCEPTION_EXECUTE_HANDLER)
    //{
    //    memcpy(pProcessName,"Get Process Name Fall",strlen("Get Process Name Fall"));
    //    return FALSE;
    //}
}
BOOL GetProcessPath(HANDLE hProcess,PCHAR pPathName)     //取进程路径
{
    NTSTATUS status;
    PROCESS_BASIC_INFORMATION    pbi;
    PEPROCESS pEprocess;
    BOOL result;
    __try
    {
        status = ZwQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL);
        if (NT_SUCCESS(status))
        {
            ConvertFileNameUNISTRToCHAR(&pbi.PebBaseAddress->ProcessParameters->ImagePathName,pPathName);
            result=TRUE;
        }
        else
        {
            //__asm int 3;
			INTERRUPT_3;
        }
    }
    
    //__except(EXCEPTION_EXECUTE_HANDLER)
    //{
    //    if(NT_SUCCESS(ObReferenceObjectByHandle(hProcess,0,NULL,KernelMode,&pEprocess,NULL)))
    //    {
    //        result=GetProcessName(pEprocess,pPathName);
    //        ObDereferenceObject (pEprocess);
    //    }
    //}
    return result;
}

PULONG GetProcessObjectState(PEPROCESS MyProcess,HANDLE MyProcessId)
{
    ULONG result;
    HANDLE TempPid;
    result=0;
    if (!MmIsAddressValid((PVOID)MyProcess))  return (PULONG)result;

    switch (g_WinVer)
    {
    case WINDOWS_VERSION_2K:
        memmove(&TempPid,(PULONG)((ULONG)MyProcess+0x9c),4);
        if (TempPid==MyProcessId) 
        {
            memmove(&result,(PULONG)((ULONG)MyProcess+0x128),4);
        }
        break;
    case WINDOWS_VERSION_XP:
        memmove(&TempPid,(PULONG)((ULONG)MyProcess+0x84),4);    //取UniqueProcessId
        if (TempPid==MyProcessId) 
        {
            memmove(&result,(PULONG)((ULONG)MyProcess+0x0c4),4);//取ObjectTable 
        }
        break;
    case WINDOWS_VERSION_2K3_SP1_SP2:
        memmove(&TempPid,(PULONG)((ULONG)MyProcess+0x94),4);
        if (TempPid==MyProcessId) 
        {
            memmove(&result,(PULONG)((ULONG)MyProcess+0x0d4),4);
        }
        break;
    case WINDOWS_VERSION_VISTA:
        memmove(&TempPid,(PULONG)((ULONG)MyProcess+0x9c),4);
        if (TempPid==MyProcessId) 
        {
            memmove(&result,(PULONG)((ULONG)MyProcess+0x0dc),4);
        }
        break;
    }

    return (PULONG)result;
}
BOOL GoOrNot(PVOID pSrc,PVOID pObj,ULONG dFun,PVOID pValue1,PVOID pValue2,PVOID pValue3)
{
    LARGE_INTEGER li;
    BOOL result;
    ULONG uAccess;
    li.QuadPart=-10000;
    
    if (NULL==GetProcessObjectState(g_MyProcess,g_MyProcessId))
    {
        return TRUE;
    }
    KeWaitForSingleObject(&g_RunEvent,Executive,KernelMode,0,0);

    if (bIsUnload)
    {
        return TRUE;
    }
    
    switch(dFun)
    {
    case SET_SYSTEMTIME_MONITOR_ON:
        dprintf("%s    ZwSetSystemTime",pSrc);
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlTimeToTimeFields((PLARGE_INTEGER)pObj,g_pTime);
        g_pMessage->function=dFun;
        break;
    case SET_VALUEKEY_MONITOR_ON:
        switch ((DWORD)pValue1)
        {
        case REG_BINARY:
            __try
            {
                RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_BINARY");
                RtlStringCchPrintfA(g_pRegData->szRegData,MAX_PATH,"%d",*((DWORD*)pValue2));
            }
            //__except(EXCEPTION_EXECUTE_HANDLER)
            //{
            //    ZeroMemory(g_pRegData->szRegData,MAX_PATH);
            //}
            break;
        case REG_DWORD:
            __try
            {
                RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_DWORD");
                RtlStringCchPrintfA(g_pRegData->szRegData,MAX_PATH,"%d",*((DWORD*)pValue2));
            }
            //__except(EXCEPTION_EXECUTE_HANDLER)
            //{
            //    ZeroMemory(g_pRegData->szRegData,MAX_PATH);
            //}
            break;
        case REG_DWORD_BIG_ENDIAN:
            __try
            {
                RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_DWORD_BIG_ENDIAN");
                RtlStringCchPrintfA(g_pRegData->szRegData,MAX_PATH,"%d",*((DWORD*)pValue2));
            }
            //__except(EXCEPTION_EXECUTE_HANDLER)
            //{
            //    ZeroMemory(g_pRegData->szRegData,MAX_PATH);
            //}
            break;
        case REG_QWORD:
            __try
            {
                RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_QWORD");
                RtlStringCchPrintfA(g_pRegData->szRegData,MAX_PATH,"%d",*((DWORD*)pValue2));
            }
            //__except(EXCEPTION_EXECUTE_HANDLER)
            //{
            //    ZeroMemory(g_pRegData->szRegData,MAX_PATH);
            //}
            break;
        case REG_EXPAND_SZ:
            RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_EXPAND_SZ");
            ConvertFileNameWCHARToCHAR((PWCHAR)pValue2,g_pRegData->szRegData);
            break;
        case REG_MULTI_SZ:
            RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_MULTI_SZ");
            ConvertFileNameWCHARToCHAR((PWCHAR)pValue2,g_pRegData->szRegData);
            break;
        case REG_SZ:
            RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_SZ");
            ConvertFileNameWCHARToCHAR((PWCHAR)pValue2,g_pRegData->szRegData);
            break;
        case REG_LINK:
            RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_LINK");
            ConvertFileNameWCHARToCHAR((PWCHAR)pValue2,g_pRegData->szRegData);
            break;
        case REG_NONE:
            RtlStringCchCopyA(g_pRegData->szRegType,25,"REG_NONE");
            ConvertFileNameWCHARToCHAR((PWCHAR)pValue2,g_pRegData->szRegData);
            break;
        default:
            ZeroMemory(g_pRegData->szRegType,2);
            ZeroMemory(g_pRegData->szRegData,2);
        }
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        dprintf("g_pRegData->szRegType:%s    g_pMessage->szRegData:%s\n",g_pRegData->szRegType,g_pRegData->szRegData);
        break;
    case SET_HOOK_MONITOR_ON:
        switch ((int)pValue1)
        {
        case -1:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_MSGFILTER");
            break;
        case 0:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_JOURNALRECORD");
            break;
        case 1:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_JOURNALPLAYBACK");
            break;
        case 2:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_KEYBOARD");
            break;
        case 3:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_GETMESSAGE");
            break;
        case 4:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_CALLWNDPROC");
            break;
        case 5:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_CBT");
            break;
        case 6:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_SYSMSGFILTER");
            break;
        case 7:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_MOUSE");
            break;
        case 8:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_HARDWARE");
            break;
        case 9:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_DEBUG");
            break;
        case 10:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_SHELL");
            break;
        case 11:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_FOREGROUNDIDLE");
            break;
        case 12:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_CALLWNDPROCRET");
            break;
        case 13:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_KEYBOARD_LL");
            break;
        case 14:
            RtlStringCchCopyA(g_pHookData->szHookType,20,"WH_MOUSE_LL");
            break;
        default:ZeroMemory(g_pHookData->szHookType,2);
        }
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        break;
    case WRITE_VIRTUAL_MEMORY_ON:
        g_pAddrData->uAddr=(ULONG)pValue1;
        RtlStringCchPrintfA(g_pAddrData->szAddr,16,"%.8xh",pValue1);
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        break;
    case CRATE_PROCESS_MONITOR_ON:
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        break;
    case LOAD_DRIVE_MONITOR_ON:
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        break;
    case SYSTEM_DEBUG_MONITER_ON:
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        break;
    case WRITE_FILE_MONITOR_ON:
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pMessage->function=dFun;
        break;
    case OPEN_SECTION_MONITOR_ON:
        RtlStringCchCopyA(g_pMessage->source,MAX_PATH,(char*)pSrc);
        RtlStringCchCopyA(g_pMessage->object,MAX_PATH,(char*)pObj);
        g_pSectionData->access_mask=(ULONG)pValue1;
        ZeroMemory(g_pSectionData->szAccess,MAX_PATH);
        uAccess=(ULONG)pValue1;
        if (SECTION_QUERY==(uAccess&SECTION_QUERY))
        {
            RtlStringCchCatA(g_pSectionData->szAccess,MAX_PATH,"SECTION_QUERY|");
        }
        uAccess=(ULONG)pValue1;
        if (SECTION_MAP_WRITE==(uAccess&SECTION_MAP_WRITE))
        {
            RtlStringCchCatA(g_pSectionData->szAccess,MAX_PATH,"SECTION_MAP_WRITE|");
        }
        uAccess=(ULONG)pValue1;
        if (SECTION_MAP_READ==(uAccess&SECTION_MAP_READ))
        {
            RtlStringCchCatA(g_pSectionData->szAccess,MAX_PATH,"SECTION_MAP_READ|");
        }
        uAccess=(ULONG)pValue1;
        if (SECTION_MAP_EXECUTE==(uAccess&SECTION_MAP_EXECUTE))
        {
            RtlStringCchCatA(g_pSectionData->szAccess,MAX_PATH,"SECTION_MAP_EXECUTE|");
        }
        uAccess=(ULONG)pValue1;
        if (SECTION_EXTEND_SIZE==(uAccess&SECTION_EXTEND_SIZE))
        {
            RtlStringCchCatA(g_pSectionData->szAccess,MAX_PATH,"SECTION_EXTEND_SIZE|");
        }
        uAccess=(ULONG)pValue1;
        if (SECTION_MAP_EXECUTE_EXPLICIT==(uAccess&SECTION_MAP_EXECUTE_EXPLICIT))
        {
            RtlStringCchCatA(g_pSectionData->szAccess,MAX_PATH,"SECTION_MAP_EXECUTE_EXPLICIT|");
        }
        uAccess=(ULONG)pValue1;
        if (SECTION_ALL_ACCESS==(uAccess&SECTION_ALL_ACCESS))
        {
            RtlStringCchCopyA(g_pSectionData->szAccess,MAX_PATH,"SECTION_ALL_ACCESS");
        }
        g_pMessage->function=dFun;
        break;
    }
    KeSetEvent((PRKEVENT)AppeventObject,0,0);
    dprintf("Waiting WitchThread\n");
    
    KeWaitForSingleObject((PRKEVENT)SyseventObject,Executive,KernelMode,0,0);
    
    KeResetEvent((PRKEVENT)SyseventObject);

    dprintf("g_pMessage->state=%d\n",g_pMessage->state);
    result=g_pMessage->state;
    KeSetEvent(&g_RunEvent,0,0);
    return result;
    
}
BOOL FakeAnyPro(IN PULONG FakeFunPos,IN ULONG NewFunValue,OUT PULONG POldFunValue,OUT PBOOL fakestate)
{
    if (!*fakestate)
    {
#ifdef _MSC_VER
		_asm
        {
            CLI                    //disable interrupt
            MOV    EAX, CR0        //move CR0 register into EAX
            AND EAX, NOT 10000H //disable WP bit
            MOV    CR0, EAX        //write register back
        }
#endif
        memmove(POldFunValue,FakeFunPos,4);
        memmove(FakeFunPos,&NewFunValue,4);
#ifdef _MSC_VER
        _asm
        {
            MOV    EAX, CR0        //move CR0 register into EAX
            OR    EAX, 10000H        //enable WP bit
            MOV    CR0, EAX        //write register back
            STI                    //enable interrupt
        }
#endif
        *fakestate = TRUE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL UnFakeAnyPro(IN PULONG FakeFunPos,IN  ULONG OldFunValue,OUT PBOOL fakestate)
{
    if (*fakestate)
    {
#ifdef _MSC_VER
        _asm
        {
            CLI                    //disable interrupt
            MOV    EAX, CR0        //move CR0 register into EAX
            AND EAX, NOT 10000H //disable WP bit
            MOV    CR0, EAX        //write register back
        }
#endif
        memmove((PULONG)FakeFunPos,&OldFunValue,4);
#ifdef _MSC_VER
        _asm
        {
            MOV    EAX, CR0        //move CR0 register into EAX
            OR    EAX, 10000H        //enable WP bit
            MOV    CR0, EAX        //write register back
            STI                    //enable interrupt
        }
#endif
        *fakestate = FALSE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID InitSysCallIndex()
{
    switch (g_WinVer)
    {
    case WINDOWS_VERSION_XP:
        Index_ZwCreateProcess=0x2f*4;                //ZwCreateProcess
        //Index_NtCreateUserProcess=-1;                //NtCreateUserProcess
        Index_ZwCreateProcessEx=0x30*4;                //ZwCreateProcessEx
        Index_ZwSetValueKey=0xf7*4;                    //ZwSetValueKey
        Index_ZwLoadDriver=0x61*4;                    //ZwLoadDriver
        Index_ZwSetSystemTime=0xf2*4;                //ZwSetSystemTime
        Index_ZwWriteVirtualMemory=0x115*4;            //ZwWriteVirtualMemory
        Index_NtSetSystemInformation=0xf0*4;        //NtSetSystemInformation
        Index_NtSystemDebugControl=0xff*4;            //NtSystemDebugControl
        Index_NtWriteFile=0x112*4;                    //NtWriteFile
        Index_NtOpenProcess=0x7a*4;                    //NtOpenProcess
        Index_ZwOpenSection=0x7d*4;                    //ZwOpenSection
        dprintf("InitSysCallIndex:WINDOWS_VERSION_XP\n");
        break;
    case WINDOWS_VERSION_2K:
        //Index_NtCreateUserProcess=-1;                //NtCreateUserProcess
        Index_ZwCreateProcess=0x29*4;                //ZwCreateProcess
        //Pos_ZwCreateProcessEx=-1;                    //ZwCreateProcessEx
        Index_ZwSetValueKey=0xd7*4;                    //ZwSetValueKey
        Index_ZwLoadDriver=0xe3*4;                    //ZwLoadDriver
        Index_ZwSetSystemTime=0xd2*4;                //ZwSetSystemTime
//        Index_ZwWriteVirtualMemory=0x115*4;            //ZwWriteVirtualMemory
        Index_NtSetSystemInformation=0xd0*4;        //NtSetSystemInformation
        Index_NtSystemDebugControl=0xde*4;            //NtSystemDebugControl
        Index_NtWriteFile=0xed*4;                    //NtWriteFile
        Index_NtOpenProcess=0x6a*4;                    //NtOpenProcess
        dprintf("InitSysCallIndex:WINDOWS_VERSION_2K\n");
        break;
    case WINDOWS_VERSION_VISTA:
        Index_NtCreateUserProcess=0x185*4;            //NtCreateUserProcess
        Index_ZwCreateProcess=0x48*4;                //ZwCreateProcess
        Index_ZwCreateProcessEx=0x49*4;                //ZwCreateProcessEx
        Index_ZwSetValueKey=0x148*4;                //ZwSetValueKey
        Index_ZwLoadDriver=0xA5*4;                    //ZwLoadDriver
        Index_ZwSetSystemTime=0x143*4;                //ZwSetSystemTime
        Index_ZwWriteVirtualMemory=0x166*4;            //ZwWriteVirtualMemory
        Index_NtSetSystemInformation=0x141*4;       //NtSetSystemInformation
        Index_NtSystemDebugControl=0x14C*4;            //NtSystemDebugControl
        Index_NtWriteFile=0x167*4;                    //NtWriteFile
        Index_NtOpenProcess=0xc2*4;                    //NtOpenProcess
        Index_ZwOpenSection=0xc5*4;                    //ZwOpenSection
        dprintf("InitSysCallIndex:WINDOWS_VERSION_VISTA\n");
        break;
    case WINDOWS_VERSION_2K3:
    case WINDOWS_VERSION_2K3_SP1_SP2:
        Index_ZwCreateProcess=0x31*4;                //ZwCreateProcess
        //Index_NtCreateUserProcess=-1;                //NtCreateUserProcess
        Index_ZwCreateProcessEx=0x32*4;                //ZwCreateProcessEx
        Index_ZwSetValueKey=0x100*4;                //ZwSetValueKey
        Index_ZwLoadDriver=0x65*4;                    //ZwLoadDriver
        Index_ZwSetSystemTime=0xfb*4;                //ZwSetSystemTime
        Index_ZwWriteVirtualMemory=0x11F*4;            //ZwWriteVirtualMemory
        Index_NtSetSystemInformation=0xf9*4;        //NtSetSystemInformation
        Index_NtSystemDebugControl=0x108*4;            //NtSystemDebugControl
        Index_NtWriteFile=0x11c*4;                    //NtWriteFile
        Index_NtOpenProcess=0x80*4;                    //NtOpenProcess
        Index_ZwOpenSection=0x83*4;                    //ZwOpenSection
        dprintf("InitSysCallIndex:WINDOWS_VERSION_2K3_SP1_SP2\n");
        break;
    }
}
//根据操作系统来确定具体函数的服务号 
VOID InitShadowCallIndex()
{
    switch (g_WinVer)
    {
    case WINDOWS_VERSION_XP:
        dprintf("InitShadowCallIndex: Running on Windows XP\n");
        Index_NtUserFindWindowEx        = 0x17A;//NtUserFindWindowEx
        Index_NtUserGetForegroundWindow = 0x194;//NtUserGetForegroundWindow
        Index_NtUserQueryWindow         = 0x1E3;//NtUserQueryWindow 
        Index_NtUserBuildHwndList       = 0x138;//NtUserBuildHwndList
        Index_NtUserWindowFromPoint     = 0x250;//NtUserWindowFromPoint
        Index_NtUserSetWindowsHookEx    = 0x225;//NtUserSetWindowsHookEx
        Index_NtUserGetDC               = 0x191;//NtUserGetDC
        Index_NtUserGetDCEx             = 0x192;//NtUserGetDCEx
        Index_NtUserSendInput           = 0x1F6;//NtUserSendInput
        Index_NtUserSetInformationThread=0x208;//NtUserSetInformationThread
        break;
    case WINDOWS_VERSION_2K:
        dprintf("InitShadowCallIndex: Running on Windows 2000\n");
        Index_NtUserFindWindowEx        = 0x170;//NtUserFindWindowEx
        Index_NtUserGetForegroundWindow = 0x189;//NtUserGetForegroundWindow
        Index_NtUserQueryWindow         = 0x1D2;//NtUserQueryWindow 
        Index_NtUserBuildHwndList       = 0x12E;//NtUserBuildHwndList 
        Index_NtUserWindowFromPoint     = 0x238;//NtUserWindowFromPoint
        Index_NtUserSetWindowsHookEx    = 0x212;//NtUserSetWindowsHookEx
        Index_NtUserGetDC               = 0x186;//NtUserGetDC
        Index_NtUserGetDCEx             = 0x187;//NtUserGetDCEx
        Index_NtUserSendInput           = 0x1E1;//NtUserSendInput
        Index_NtUserSetInformationThread=0x1f5;//NtUserSetInformationThread
        break;
    case WINDOWS_VERSION_VISTA:
        dprintf("InitShadowCallIndex: Running on Windows VISTA\n");
        Index_NtUserFindWindowEx        = 0x187;//NtUserFindWindowEx
        Index_NtUserGetForegroundWindow = 0x1A2;//NtUserGetForegroundWindow
        Index_NtUserQueryWindow         = 0x1F8;//NtUserQueryWindow 
        Index_NtUserBuildHwndList       = 0x142;//NtUserBuildHwndList 
        Index_NtUserWindowFromPoint     = 0x269;//NtUserWindowFromPoint
        Index_NtUserSetWindowsHookEx    = 0x23D;//NtUserSetWindowsHookEx
        Index_NtUserGetDC               = 0x19F;//NtUserGetDC
        Index_NtUserGetDCEx             = 0x1A0;//NtUserGetDCEx
        Index_NtUserSendInput           = 0x20D;//NtUserSendInput
        Index_NtUserSetInformationThread=0x21e;//NtUserSetInformationThread
        break;
    case WINDOWS_VERSION_2K3:
    case WINDOWS_VERSION_2K3_SP1_SP2:
        dprintf("InitShadowCallIndex: Running on Windows 2003\n");
        Index_NtUserFindWindowEx        = 0x179;//NtUserFindWindowEx
        Index_NtUserGetForegroundWindow = 0x193;//NtUserGetForegroundWindow
        Index_NtUserQueryWindow         = 0x1E1;//NtUserQueryWindow 
        Index_NtUserBuildHwndList       = 0x137;//NtUserBuildHwndList
        Index_NtUserWindowFromPoint     = 0x24C;//NtUserWindowFromPoint
        Index_NtUserSetWindowsHookEx    = 0x221;//NtUserSetWindowsHookEx
        Index_NtUserGetDC               = 0x190;//NtUserGetDC
        Index_NtUserGetDCEx             = 0x191;//NtUserGetDCEx
        Index_NtUserSendInput           = 0x1F4;//NtUserSendInput
        Index_NtUserSetInformationThread=0x205;//NtUserSetInformationThread
        break;
    }
}
//获取KeServiceDescriptorTableShadow地址
unsigned int GetAddressOfShadowTable()
{
    unsigned int i;
    unsigned char *p;
    unsigned int dwordatbyte;
    //__declspec(dllimport) _stdcall KeAddSystemServiceTable(PVOID, PVOID, PVOID, PVOID, PVOID);
    p = (unsigned char*) KeAddSystemServiceTable;

    for(i = 0; i < 4096; i++, p++)
    {
        __try
        {
            dwordatbyte = *(unsigned int*)p;
        }
        //__except(EXCEPTION_EXECUTE_HANDLER)
        //{
        //    return 0;
        //}
        if(MmIsAddressValid((PVOID)dwordatbyte))
        {
            if(memcmp((PVOID)dwordatbyte,KeServiceDescriptorTable, 16) == 0)
            {
                if((PVOID)dwordatbyte == KeServiceDescriptorTable)
                {
                    continue;
                }
                return dwordatbyte;
            }
        }
    }
    return 0;
}

//另一种获取KeServiceDescriptorTableShadow地址的方法
PULONG GetAddressOfShadowTable2() 
{ 
    PUCHAR Buff; 
    PUCHAR p;
    UNICODE_STRING usKeAddSystemServiceTable; 
    PULONG ShadowTable; 

    RtlInitUnicodeString(&usKeAddSystemServiceTable, 
        L"KeAddSystemServiceTable"); 
    Buff = (PUCHAR)MmGetSystemRoutineAddress(&usKeAddSystemServiceTable); 
    for( p=Buff; p < Buff+PAGE_SIZE; p++ ) 
    { 
        if( MmIsAddressValid( (PVOID)p ) )
        {
            if( (*(PUSHORT)p == 0x888D ) && (*(p+6) == 0x83 ) ) 
            { 
                ShadowTable = (PULONG)(p+2);
                break; 
            }
        } 
    } 
    dprintf("KeGetKeServiceDescriptorTableShadow2(XPSP2:80553340) = 0x%08X\n", 
        *(PULONG)ShadowTable );
    return ShadowTable ? ShadowTable : NULL;
}
ULONG GetShadowTable()
{
    KeServiceDescriptorTableShadow = (PServiceDescriptorTableEntry)GetAddressOfShadowTable();
    if(KeServiceDescriptorTableShadow == NULL)
    {
        KeServiceDescriptorTableShadow = (PServiceDescriptorTableEntry)GetAddressOfShadowTable2();
        if (NULL==KeServiceDescriptorTableShadow)
        {
            dprintf("GetAddressOfShadowTablet2: Couldnt find shadowtable!\n");
            return FALSE;
        }
        
    }
    dprintf("GetAddressOfShadowTablet: Shadowtable has been found!\n");
    dprintf("GetAddressOfShadowTable: Shadowtable entries: 0x%x\n", KeServiceDescriptorTableShadow[1].NumberOfServices);
//    dprintf("NtUserSetWindowsHookEx: 0x%x\n", KeServiceDescriptorTableShadow[1].ServiceTableBase[NtUserSetWindowsHookExIndex]);    
    return TRUE;
} 

NTSTATUS FakedZwCreateProcess (OUT PHANDLE ProcessHandle,
                               IN ACCESS_MASK DesiredAccess,
                               IN POBJECT_ATTRIBUTES ObjectAttributes,
                               IN HANDLE ParentProcess,
                               IN BOOLEAN InheritObjectTable,
                               IN HANDLE SectionHandle,
                               IN HANDLE DebugPort,
                               IN HANDLE ExceptionPort)
{
    char aProcessName[MAX_PATH];
    char aPathName[MAX_PATH];
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    if (ProcessHandle==0) 
    {
        --Quote_HookDrive;
        return STATUS_INVALID_HANDLE;
    }
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||g_ServicesProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return ((ZWCREATEPROCESS)Real_ZwCreateProcess)(
            ProcessHandle,
            DesiredAccess,
            ObjectAttributes,
            ParentProcess,
            InheritObjectTable,
            SectionHandle,
            DebugPort,
            ExceptionPort);
    }
    else
    {
        ZeroMemory(aProcessName,MAX_PATH);
        GetFilePath(SectionHandle,aPathName);
        GetProcessPath((HANDLE)-1,aProcessName);
        dprintf("%s ZwCreateProcess %s\n", aProcessName,aPathName);
        if (GoOrNot(aProcessName,aPathName,CRATE_PROCESS_MONITOR_ON,NULL,NULL,NULL))
        {
            --Quote_HookDrive;
            return ((ZWCREATEPROCESS)Real_ZwCreateProcess)(
                ProcessHandle,
                DesiredAccess,
                ObjectAttributes,
                ParentProcess,
                InheritObjectTable,
                SectionHandle,
                DebugPort,
                ExceptionPort);
        }
        else
        {
            --Quote_HookDrive;
            return STATUS_ACCESS_DENIED;
        }
    }
}
NTSTATUS FakedZwCreateProcessEx(
                                OUT PHANDLE ProcessHandle,
                                IN ACCESS_MASK DesiredAccess,
                                IN POBJECT_ATTRIBUTES ObjectAttributes,
                                IN HANDLE InheritFromProcessHandle,
                                IN BOOLEAN InheritHandles,
                                IN HANDLE SectionHandle OPTIONAL,
                                IN HANDLE DebugPort OPTIONAL,
                                IN HANDLE ExceptionPort OPTIONAL,
                                IN HANDLE Unknown 
                                )
{
    char aProcessName[MAX_PATH];
    char aPathName[MAX_PATH];
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    if (ProcessHandle==0) 
    {
        --Quote_HookDrive;
        return STATUS_INVALID_HANDLE;
    }
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||g_ServicesProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return ((ZWCREATEPROCESSEX)Real_ZwCreateProcessEx)(
            ProcessHandle,
            DesiredAccess,
            ObjectAttributes,
            InheritFromProcessHandle,
            InheritHandles,
            SectionHandle,
            DebugPort,
            ExceptionPort,
            Unknown
            );
    }
    else
    {
        ZeroMemory(aProcessName,MAX_PATH);
        GetFilePath(SectionHandle,aPathName);
        GetProcessPath((HANDLE)-1,aProcessName);
        dprintf("%s ZwCreateProcessEx %s\n", aProcessName,aPathName);
        if (GoOrNot(aProcessName,aPathName,CRATE_PROCESS_MONITOR_ON,NULL,NULL,NULL))
        {
            --Quote_HookDrive;
            return ((ZWCREATEPROCESSEX)Real_ZwCreateProcessEx)(
                ProcessHandle,
                DesiredAccess,
                ObjectAttributes,
                InheritFromProcessHandle,
                InheritHandles,
                SectionHandle,
                DebugPort,
                ExceptionPort,
                Unknown
                );
        }
        else
        {
            --Quote_HookDrive;
            return STATUS_ACCESS_DENIED;
        }

    }
}

NTSTATUS FakedNtCreateUserProcess (PHANDLE ProcessHandle,
                                   PHANDLE ThreadHandle,
                                   PVOID Parameter2,
                                   PVOID Parameter3,
                                   PVOID ProcessSecurityDescriptor,
                                   PVOID ThreadSecurityDescriptor,
                                   PVOID Parameter6,
                                   PVOID Parameter7,
                                   PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
                                   PVOID Parameter9,
                                   PVOID pProcessUnKnow)
{
    char aProcessName[MAX_PATH];
    char aPathName[MAX_PATH];
    PWCHAR    wszFilePath ;
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||g_ServicesProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return  ((NTCREATEUSERPROCESS)Real_NtCreateUserProcess) (ProcessHandle,
            ThreadHandle,
            Parameter2,
            Parameter3,
            ProcessSecurityDescriptor,
            ThreadSecurityDescriptor,
            Parameter6,
            Parameter7,
            ProcessParameters,
            Parameter9,
            pProcessUnKnow);
    }
    else
    {
        ZeroMemory(aProcessName,MAX_PATH);
        ConvertFileNameWCHARToCHAR(ProcessParameters->ImagePathName.Buffer,aPathName);
        GetProcessPath((HANDLE)-1,aProcessName);
        dprintf("%s NtCreateUserProcess %s\n", aProcessName,aPathName);
        if (GoOrNot(aProcessName,aPathName,CRATE_PROCESS_MONITOR_ON,NULL,NULL,NULL))
        {
            --Quote_HookDrive;
            return  ((NTCREATEUSERPROCESS)Real_NtCreateUserProcess) (ProcessHandle,
                ThreadHandle,
                Parameter2,
                Parameter3,
                ProcessSecurityDescriptor,
                ThreadSecurityDescriptor,
                Parameter6,
                Parameter7,
                ProcessParameters,
                Parameter9,
                pProcessUnKnow);
        }
        else
        {
            --Quote_HookDrive;
            return STATUS_ACCESS_DENIED;
        }
    }
}

NTSTATUS FakedZwSetValueKey
(
 IN HANDLE  KeyHandle,
 IN PUNICODE_STRING  ValueName,
 IN ULONG  TitleIndex  OPTIONAL,
 IN ULONG  Type,
 IN PVOID  Data,
 IN ULONG  DataSize
 )
{
    PEPROCESS TempCurrentProcess;
    char szCurrentProcess[MAX_PATH];
    char szTemp[MAX_PATH];
    char szKeyPath[MAX_PATH];
    ULONG result;
    ++Quote_HookDrive;
    if (KeyHandle==0) 
    {
        --Quote_HookDrive;
        return STATUS_SUCCESS;
    }
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||g_SystemProcess==TempCurrentProcess||\
        g_CsrssProcess==TempCurrentProcess||g_SmssProcess==TempCurrentProcess||\
        g_LsassProcess==TempCurrentProcess||g_WinlogonProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return ((ZWSETVALUEKEY)Real_ZwSetValueKey)(
            KeyHandle,
            ValueName,
            TitleIndex,
            Type,
            Data,
            DataSize);
    }
    GetProcessPath((HANDLE)-1,szCurrentProcess);
    GetRegPath(KeyHandle,szKeyPath);
    ConvertFileNameUNISTRToCHAR(ValueName,szTemp);
    RtlStringCchCatA(szKeyPath,MAX_PATH,"\\");
    RtlStringCchCatA(szKeyPath,MAX_PATH,szTemp);
    dprintf("%s ZwSetValueKey %s\n", szCurrentProcess,szKeyPath);
    if (GoOrNot(szCurrentProcess,szKeyPath,SET_VALUEKEY_MONITOR_ON,(PVOID)Type,Data,NULL))
    {
        --Quote_HookDrive;
        return ((ZWSETVALUEKEY)Real_ZwSetValueKey)(
            KeyHandle,
            ValueName,
            TitleIndex,
            Type,
            Data,
            DataSize);
    }
    --Quote_HookDrive;
    return STATUS_ACCESS_DENIED;
}

NTSTATUS FakedZwSetSystemTime(PLARGE_INTEGER NewTime,PLARGE_INTEGER OldTime)
{
    char aProcessName[MAX_PATH];
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return  ((ZWSETSYSTEMTIME)Real_ZwSetSystemTime)(NewTime,OldTime);
    }
    GetProcessPath((HANDLE)-1,aProcessName);
    dprintf("%s    ZwSetSystemTime",aProcessName);
    if (GoOrNot(aProcessName,NewTime,SET_SYSTEMTIME_MONITOR_ON,NULL,NULL,NULL))
    {
        --Quote_HookDrive;
        return  ((ZWSETSYSTEMTIME)Real_ZwSetSystemTime)(NewTime,OldTime);
    }
    --Quote_HookDrive;
    return STATUS_PRIVILEGE_NOT_HELD;
}

NTSTATUS FakedZwLoadDriver(IN PUNICODE_STRING DriverServiceName )
{
    char aProcessName[MAX_PATH];
    char aDrvname[MAX_PATH];
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    if (DriverServiceName==NULL) 
    {
        --Quote_HookDrive;
        return STATUS_SUCCESS;
    }
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return ((ZWLOADDRIVER)Real_ZwLoadDriver)(
            DriverServiceName
            );
    }
    else
    {
        GetProcessPath((HANDLE)-1,aProcessName);
        ConvertFileNameUNISTRToCHAR(DriverServiceName,aDrvname);
        dprintf("%s ZwLoadDriver %s\n", aProcessName,aDrvname);
        if (TRUE==GoOrNot(aProcessName,aDrvname,LOAD_DRIVE_MONITOR_ON,NULL,NULL,NULL))
        {
            --Quote_HookDrive;
            return ((ZWLOADDRIVER)Real_ZwLoadDriver)(
                DriverServiceName
                );
        }
        else
        {
            --Quote_HookDrive;
            return STATUS_ACCESS_DENIED;
        }
    }
}
NTSTATUS FakedZwWriteVirtualMemory(IN HANDLE ProcessHandle,IN PVOID BaseAddress,IN PVOID Buffer,IN ULONG BufferLength,OUT PULONG ReturnLength OPTIONAL)
{
    PEPROCESS TempCurrentProcess;

    PEPROCESS SrcProcess=0;
    ULONG uProcessName;
    char szCurrentProcess[MAX_PATH];
    char szObjectProcess[MAX_PATH];
    ++Quote_HookDrive;
    TempCurrentProcess=PsGetCurrentProcess();
    ObReferenceObjectByHandle(ProcessHandle,0,NULL,KernelMode,&SrcProcess,NULL);
    if (g_MyProcess==TempCurrentProcess||g_SystemProcess==TempCurrentProcess||\
        g_CsrssProcess==TempCurrentProcess||g_SmssProcess==TempCurrentProcess||\
        g_LsassProcess==TempCurrentProcess||g_WinlogonProcess==TempCurrentProcess||g_ServicesProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return ((ZWWRITEVIRTUALMEMORY)Real_ZwWriteVirtualMemory)(ProcessHandle,BaseAddress,Buffer,BufferLength,ReturnLength);
    }
    ObDereferenceObject (SrcProcess);
    GetProcessPath((HANDLE)-1,szCurrentProcess);
    GetProcessPath(ProcessHandle,szObjectProcess);
    dprintf("%s:ZwWriteVirtualMemory %s    0x%x\n",szCurrentProcess,szObjectProcess,BaseAddress);
    if (GoOrNot(szCurrentProcess,szObjectProcess,WRITE_VIRTUAL_MEMORY_ON,BaseAddress,NULL,NULL))
    {
        --Quote_HookDrive;
        return ((ZWWRITEVIRTUALMEMORY)Real_ZwWriteVirtualMemory)(ProcessHandle,BaseAddress,Buffer,BufferLength,ReturnLength);
    }
    else
    {
        --Quote_HookDrive;
        return STATUS_ACCESS_VIOLATION;
    }
}
NTSTATUS FakedNtSetSystemInformation(IN SYSTEM_INFORMATION_CLASS SystemInformationClass,IN OUT PVOID SystemInformation,IN ULONG SystemInformationLength)
{
    char aProcessName[MAX_PATH];
    char aDrvname[MAX_PATH];
    PEPROCESS TempCurrentProcess;
    PSYSTEM_LOAD_AND_CALL_IMAGE newimage;
    ++Quote_HookDrive;
    if (NULL==SystemInformation) 
    {
        --Quote_HookDrive;
        return STATUS_INVALID_INFO_CLASS;
    }
    TempCurrentProcess=PsGetCurrentProcess();
    if ((g_MyProcess==TempCurrentProcess) || (SystemInformationClass!=SystemLoadAndCallImage)||bIsUnload)
    {
        --Quote_HookDrive;
        return ((NTSETSYSTEMINFORMATION)Real_NtSetSystemInformation)(
            SystemInformationClass,
            SystemInformation,
            SystemInformationLength
            );
    }
    else
    {
        GetProcessPath((HANDLE)-1,aProcessName);
        newimage=(PSYSTEM_LOAD_AND_CALL_IMAGE)SystemInformation;
        ConvertFileNameUNISTRToCHAR(&(newimage->ModuleName),aDrvname);
        dprintf("%s NtSetSystemInformation %s\n", aProcessName,aDrvname);
        if (GoOrNot(aProcessName,aDrvname,LOAD_DRIVE_MONITOR_ON,NULL,NULL,NULL))
        {
            --Quote_HookDrive;
            return ((NTSETSYSTEMINFORMATION)Real_NtSetSystemInformation)(
                SystemInformationClass,
                SystemInformation,
                SystemInformationLength
                );
        }
        --Quote_HookDrive;
        return STATUS_INVALID_INFO_CLASS;
    }
}

NTSTATUS FakedNtSystemDebugControl(IN DEBUG_CONTROL_CODE ControlCode,IN PVOID InputBuffer OPTIONAL,IN ULONG InputBufferLength,OUT PVOID OutputBuffer OPTIONAL,IN ULONG OutputBufferLength,OUT PULONG ReturnLength OPTIONAL)
{
    PEPROCESS TempCurrentProcess;
    char aProcessName[MAX_PATH];
    char szControlCode[30];
    ++Quote_HookDrive;
    TempCurrentProcess=PsGetCurrentProcess();
    if ((g_MyProcess==TempCurrentProcess) || bIsUnload)
    {
        --Quote_HookDrive;
        return ((NTSYSTEMDEBUGCONTROL)Real_NtSystemDebugControl)(
            ControlCode,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength,
            ReturnLength
            );
    }
    else
    {
        GetProcessPath((HANDLE)-1,aProcessName);
        switch (ControlCode)
        {
        case SysDbgQueryModuleInformation:
            RtlStringCchCopyA(szControlCode,30,"SysDbgQueryModuleInformation");
            break;
        case SysDbgQueryTraceInformation:
            RtlStringCchCopyA(szControlCode,30,"SysDbgQueryTraceInformation");
            break;
        case SysDbgSetTracepoint:
            RtlStringCchCopyA(szControlCode,30,"SysDbgSetTracepoint");
            break;
        case SysDbgSetSpecialCall:
            RtlStringCchCopyA(szControlCode,30,"SysDbgSetSpecialCall");
            break;
        case SysDbgClearSpecialCalls:
            RtlStringCchCopyA(szControlCode,30,"SysDbgClearSpecialCalls");
            break;
        case SysDbgQuerySpecialCalls:
            RtlStringCchCopyA(szControlCode,30,"SysDbgQuerySpecialCalls");
            break;
        case SysDbgBreakPoint:
            RtlStringCchCopyA(szControlCode,30,"SysDbgBreakPoint");
            break;
        case SysDbgQueryVersion:
            RtlStringCchCopyA(szControlCode,30,"SysDbgQueryVersion");
            break;
        case SysDbgReadVirtual:
            RtlStringCchCopyA(szControlCode,30,"SysDbgReadVirtual");
            break;
        case SysDbgWriteVirtual:
            RtlStringCchCopyA(szControlCode,30,"SysDbgWriteVirtual");
            break;
        case SysDbgReadPhysical:
            RtlStringCchCopyA(szControlCode,30,"SysDbgReadPhysical");
            break;
        case SysDbgWritePhysical:
            RtlStringCchCopyA(szControlCode,30,"SysDbgWritePhysical");
            break;
        case SysDbgReadControlSpace:
            RtlStringCchCopyA(szControlCode,30,"SysDbgReadControlSpace");
            break;
        case SysDbgWriteControlSpace:
            RtlStringCchCopyA(szControlCode,30,"SysDbgWriteControlSpace");
            break;
        case SysDbgReadIoSpace:
            RtlStringCchCopyA(szControlCode,30,"SysDbgReadIoSpace");
            break;
        case SysDbgWriteIoSpace:
            RtlStringCchCopyA(szControlCode,30,"SysDbgWriteIoSpace");
            break;
        case SysDbgReadMsr:
            RtlStringCchCopyA(szControlCode,30,"SysDbgReadMsr");
            break;
        case SysDbgWriteMsr:
            RtlStringCchCopyA(szControlCode,30,"SysDbgWriteMsr");
            break;
        case SysDbgReadBusData:
            RtlStringCchCopyA(szControlCode,30,"SysDbgReadBusData");
            break;
        case SysDbgWriteBusData:
            RtlStringCchCopyA(szControlCode,30,"SysDbgWriteBusData");
            break;
        case SysDbgCheckLowMemory:
            RtlStringCchCopyA(szControlCode,30,"SysDbgCheckLowMemory");
            break;
        case SysDbgEnableKernelDebugger:
            RtlStringCchCopyA(szControlCode,30,"SysDbgEnableKernelDebugger");
            break;
        case SysDbgDisableKernelDebugger:
            RtlStringCchCopyA(szControlCode,30,"SysDbgDisableKernelDebugger");
            break;
        case SysDbgGetAutoKdEnable:
            RtlStringCchCopyA(szControlCode,30,"SysDbgGetAutoKdEnable");
            break;
        case SysDbgSetAutoKdEnable:
            RtlStringCchCopyA(szControlCode,30,"SysDbgSetAutoKdEnable");
            break;
        case SysDbgGetPrintBufferSize:
            RtlStringCchCopyA(szControlCode,30,"SysDbgGetPrintBufferSize");
            break;
        case SysDbgSetPrintBufferSize:
            RtlStringCchCopyA(szControlCode,30,"SysDbgSetPrintBufferSize");
            break;
        case SysDbgGetKdUmExceptionEnable:
            RtlStringCchCopyA(szControlCode,30,"SysDbgGetKdUmExceptionEnable");
            break;
        case SysDbgSetKdUmExceptionEnable:
            RtlStringCchCopyA(szControlCode,30,"SysDbgSetKdUmExceptionEnable");
            break;
        case SysDbgGetTriageDump:
            RtlStringCchCopyA(szControlCode,30,"SysDbgGetTriageDump");
            break;
        case SysDbgGetKdBlockEnable:
            RtlStringCchCopyA(szControlCode,30,"SysDbgGetKdBlockEnable");
            break;
        case SysDbgSetKdBlockEnable:
            RtlStringCchCopyA(szControlCode,30,"SysDbgSetKdBlockEnable");
            break;
        }
        dprintf("%s NtSystemDebugControl:%s\n", aProcessName,szControlCode);
        if (GoOrNot(aProcessName,szControlCode,SYSTEM_DEBUG_MONITER_ON,NULL,NULL,NULL))
        {
            --Quote_HookDrive;
            return ((NTSYSTEMDEBUGCONTROL)Real_NtSystemDebugControl)(
                ControlCode,
                InputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength,
                ReturnLength
                );
        }
        --Quote_HookDrive;
        return RETURN_ERRO_NOBOX;
    }
}


NTSTATUS FakedNtWriteFile(
                          IN HANDLE FileHandle,
                          IN HANDLE Event OPTIONAL,
                          IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
                          IN PVOID ApcContext OPTIONAL,
                          OUT PIO_STATUS_BLOCK IoStatusBlock,
                          IN PVOID Buffer,
                          IN ULONG Length,
                          IN PLARGE_INTEGER ByteOffset OPTIONAL,
                          IN PULONG Key OPTIONAL
                          )
{
    char aFilename[MAX_PATH]={0};
    char aProcessName[MAX_PATH];
    PEPROCESS TempCurrentProcess;

    ++Quote_HookDrive;
    if  (FileHandle==0)
    {
        --Quote_HookDrive;
        return STATUS_SUCCESS;
    }
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||g_SystemProcess==TempCurrentProcess||\
        g_CsrssProcess==TempCurrentProcess||g_SmssProcess==TempCurrentProcess||\
        g_LsassProcess==TempCurrentProcess||g_WinlogonProcess==TempCurrentProcess||bIsUnload||STATUS_SUCCESS!=GetFilePathVista(FileHandle,aFilename))
    {
        --Quote_HookDrive;
        return  ((NTWRITEFILE)Real_NtWriteFile)(
            FileHandle,
            Event,
            ApcRoutine,
            ApcContext,
            IoStatusBlock,
            Buffer,
            Length,
            ByteOffset,
            Key
            );
    }
    GetProcessPath((HANDLE)-1,aProcessName);
    dprintf("%s NtWriteFile %s\n", aProcessName,aFilename);
    if (GoOrNot(aProcessName,aFilename,WRITE_FILE_MONITOR_ON,NULL,NULL,NULL))
    {
        --Quote_HookDrive;
        return  ((NTWRITEFILE)Real_NtWriteFile)(
            FileHandle,
            Event,
            ApcRoutine,
            ApcContext,
            IoStatusBlock,
            Buffer,
            Length,
            ByteOffset,
            Key
            );
    }
    --Quote_HookDrive;
    return STATUS_ACCESS_DENIED;

}
HHOOK FakedNtUserSetWindowsHookEx(
                                   HINSTANCE Mod, 
                                   PUNICODE_STRING UnsafeModuleName, 
                                   DWORD ThreadId, 
                                   int HookId, 
                                   PVOID HookProc, 
                                   BOOL Ansi )
{
    char szModuleName[MAX_PATH];
    char aProcessName[MAX_PATH];
    char szHookTyep[20];
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    ConvertFileNameUNISTRToCHAR(UnsafeModuleName,szModuleName);
    TempCurrentProcess=PsGetCurrentProcess();
    if (g_MyProcess==TempCurrentProcess||0!=ThreadId||bIsUnload)
    {
        --Quote_HookDrive;
        return  ((NTUSERSETWINDOWSHOOKEX)Real_NtUserSetWindowsHookEx)(Mod,UnsafeModuleName,ThreadId,HookId,HookProc,Ansi);
    }
    GetProcessPath((HANDLE)-1,aProcessName);
    dprintf("%s NtUserSetWindowsHookEx %wZ\n", aProcessName,UnsafeModuleName);
    if (GoOrNot(aProcessName,szModuleName,SET_HOOK_MONITOR_ON,(PVOID)HookId,NULL,NULL))
    {
        --Quote_HookDrive;
        return  ((NTUSERSETWINDOWSHOOKEX)Real_NtUserSetWindowsHookEx)(Mod,UnsafeModuleName,ThreadId,HookId,HookProc,Ansi);
    }
    --Quote_HookDrive;
    return 0;
}
NTSTATUS FakedZwOpenSection(PHANDLE SectionHandle,ACCESS_MASK DesiredAccess,POBJECT_ATTRIBUTES ObjectAttributes)
{
    char szCurrentProcess[MAX_PATH];
    char szObjSection[MAX_PATH];
    PEPROCESS TempCurrentProcess;
    ++Quote_HookDrive;
    TempCurrentProcess=PsGetCurrentProcess();
    ConvertFileNameUNISTRToCHAR(ObjectAttributes->ObjectName,szObjSection);
    if (g_MyProcess==TempCurrentProcess||g_CsrssProcess==TempCurrentProcess||bIsUnload)
    {
        --Quote_HookDrive;
        return ((ZWOPENSECTION)Real_ZwOpenSection)(SectionHandle,DesiredAccess,ObjectAttributes);
    }
    GetProcessPath((HANDLE)-1,szCurrentProcess);
    dprintf("%s ZwOpenSection %wZ\n", szCurrentProcess,ObjectAttributes->ObjectName);
    if (GoOrNot(szCurrentProcess,szObjSection,OPEN_SECTION_MONITOR_ON,(PVOID)DesiredAccess,NULL,NULL))
    {
        --Quote_HookDrive;
        return ((ZWOPENSECTION)Real_ZwOpenSection)(SectionHandle,DesiredAccess,ObjectAttributes);
    }
    --Quote_HookDrive;
    return STATUS_ACCESS_DENIED;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID ProcMoniterOn()
{
    if (Index_ZwCreateProcess)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwCreateProcess),(ULONG)FakedZwCreateProcess,&Real_ZwCreateProcess,&State_ZwCreateProcess);

    if (Index_ZwCreateProcessEx)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwCreateProcessEx),(ULONG)FakedZwCreateProcessEx,&Real_ZwCreateProcessEx,&State_ZwCreateProcessEx);

    if (Index_NtCreateUserProcess)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_NtCreateUserProcess),(ULONG)FakedNtCreateUserProcess,&Real_NtCreateUserProcess,&State_NtCreateUserProcess);
    dprintf("CRATE_PROCESS_MONITOR_ON\n");
}

VOID ProcMoniterOff()
{
    if (Index_ZwCreateProcess)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwCreateProcess),Real_ZwCreateProcess,&State_ZwCreateProcess);

    if (Index_ZwCreateProcessEx)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwCreateProcessEx),Real_ZwCreateProcessEx,&State_ZwCreateProcessEx);

    if (Index_NtCreateUserProcess)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_NtCreateUserProcess),Real_NtCreateUserProcess,&State_NtCreateUserProcess);
    dprintf("CRATE_PROCESS_MONITOR_OFF\n");
}

VOID RegMoniterOn()
{
    if (Index_ZwSetValueKey)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwSetValueKey),(ULONG)FakedZwSetValueKey,&Real_ZwSetValueKey,&State_ZwSetValueKey);
    dprintf("SET_VALUEKEY_MONITOR_ON\n");
}

VOID RegMoniterOff()
{
    if (Index_ZwSetValueKey)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwSetValueKey),Real_ZwSetValueKey,&State_ZwSetValueKey);
    dprintf("SET_VALUEKEY_MONITOR_OFF\n");
}

VOID ModMonitorOn()
{
    if (Index_ZwLoadDriver)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwLoadDriver),(ULONG)FakedZwLoadDriver,&Real_ZwLoadDriver,&State_ZwLoadDriver);

    if (Index_NtSetSystemInformation)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_NtSetSystemInformation),(ULONG)FakedNtSetSystemInformation,&Real_NtSetSystemInformation,&State_NtSetSystemInformation);
    dprintf("LOAD_DRIVE_MONITOR_ON\n");
}

VOID ModMonitorOff()
{
    if (Index_ZwLoadDriver)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwLoadDriver),Real_ZwLoadDriver,&State_ZwLoadDriver);

    if (Index_NtSetSystemInformation)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_NtSetSystemInformation),Real_NtSetSystemInformation,&State_NtSetSystemInformation);
    dprintf("LOAD_DRIVE_MONITOR_OFF\n");
}

VOID TimeSafeOn()
{
    if (Index_ZwSetSystemTime)
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwSetSystemTime),(ULONG)FakedZwSetSystemTime,&Real_ZwSetSystemTime,&State_ZwSetSystemTime);
    dprintf("SET_SYSTEMTIME_MONITOR_ON\n");
}

VOID TimeSafeOff()
{
    if (Index_ZwSetSystemTime)
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwSetSystemTime),Real_ZwSetSystemTime,&State_ZwSetSystemTime);
    dprintf("SET_SYSTEMTIME_MONITOR_OFF\n");
}
VOID HookMoniterOn()
{
    if (Index_NtUserSetWindowsHookEx)
    {
        ApcState = (PKAPC_STATE)ExAllocatePool(NonPagedPool, sizeof(KAPC_STATE));
        KeStackAttachProcess(g_CsrssProcess, ApcState);
        FakeAnyPro((PULONG)(KeServiceDescriptorTableShadow[1].ServiceTableBase+Index_NtUserSetWindowsHookEx),(ULONG)FakedNtUserSetWindowsHookEx,&Real_NtUserSetWindowsHookEx,&State_NtUserSetWindowsHookEx);
        KeUnstackDetachProcess(ApcState);
        ExFreePool(ApcState);
    }
    dprintf("SET_HOOK_MONITOR_ON\n");
}
VOID HookMoniterOff()
{
    if (Index_NtUserSetWindowsHookEx)
    {
        ApcState = (PKAPC_STATE)ExAllocatePool(NonPagedPool, sizeof(KAPC_STATE));
        KeStackAttachProcess(g_CsrssProcess, ApcState);
        UnFakeAnyPro((PULONG)(KeServiceDescriptorTableShadow[1].ServiceTableBase+Index_NtUserSetWindowsHookEx),Real_NtUserSetWindowsHookEx,&State_NtUserSetWindowsHookEx);
        KeUnstackDetachProcess(ApcState);
        ExFreePool(ApcState);
    }
    dprintf("SET_HOOK_MONITOR_OFF\n");
}
VOID WriteFileMoniterOn()
{
    if (Index_NtWriteFile)
    {
        FakeAnyPro((PULONG)(SSDTTableBase + Index_NtWriteFile),(ULONG)FakedNtWriteFile,&Real_NtWriteFile,&State_NtWriteFile);
        dprintf("WRITE_FILE_MONITOR_ON\n");
    }
}
VOID WriteFileMoniterOff()
{
    if (Index_NtWriteFile)
    {
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_NtWriteFile),Real_NtWriteFile,&State_NtWriteFile);
        dprintf("WRITE_FILE_MONITOR_OFF\n");
    }
}
VOID SystemDebugMoniterOn()
{
    if (Index_NtSystemDebugControl)
    {
        FakeAnyPro((PULONG)(SSDTTableBase + Index_NtSystemDebugControl),(ULONG)FakedNtSystemDebugControl,&Real_NtSystemDebugControl,&State_NtSystemDebugControl);
    }
    dprintf("SYSTEM_DEBUG_MONITER_ON\n");
}
VOID SystemDebugMoniterOff()
{
    if (Index_NtSystemDebugControl)
    {
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_NtSystemDebugControl),Real_NtSystemDebugControl,&State_NtSystemDebugControl);
    }
    dprintf("SYSTEM_DEBUG_MONITER_OFF\n");
}
VOID WriteVirtualMemoryOn()
{
    if (Index_ZwWriteVirtualMemory)
    {
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwWriteVirtualMemory),(ULONG)FakedZwWriteVirtualMemory,&Real_ZwWriteVirtualMemory,&State_ZwWriteVirtualMemory);
    }
    dprintf("WRITE_VIRTUAL_MEMORY_ON\n");
}

VOID WriteVirtualMemoryOff()
{
    if (Index_ZwWriteVirtualMemory)
    {
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwWriteVirtualMemory),Real_ZwWriteVirtualMemory,&State_ZwWriteVirtualMemory);
    }
    dprintf("WRITE_VIRTUAL_MEMORY_OFF\n");
}

VOID OpenSectionOn()
{
    if (Index_ZwOpenSection)
    {
        FakeAnyPro((PULONG)(SSDTTableBase + Index_ZwOpenSection),(ULONG)FakedZwOpenSection,&Real_ZwOpenSection,&State_ZwOpenSection);
    }
    dprintf("OPEN_SECTION_ON\n");
}

VOID OpenSectionOff()
{
    if (Index_ZwOpenSection)
    {
        UnFakeAnyPro((PULONG)(SSDTTableBase + Index_ZwOpenSection),Real_ZwOpenSection,&State_ZwOpenSection);
    }
    dprintf("OPEN_SECTION_OFF\n");
}
